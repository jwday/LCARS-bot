{"version":3,"file":"index.js","sources":["../src/parse-path.js","../src/path2d-polyfill.js","../src/index.js"],"sourcesContent":["const ARG_LENGTH = {\n  a: 7,\n  c: 6,\n  h: 1,\n  l: 2,\n  m: 2,\n  q: 4,\n  s: 4,\n  t: 2,\n  v: 1,\n  z: 0,\n};\n\nconst SEGMENT_PATTERN = /([astvzqmhlc])([^astvzqmhlc]*)/gi;\n\nconst NUMBER = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/gi;\n\nfunction parseValues(args) {\n  const numbers = args.match(NUMBER);\n  return numbers ? numbers.map(Number) : [];\n}\n\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * https://www.w3.org/TR/SVG/paths.html#PathDataGeneralInformation\n * @ignore\n *\n * @param {string} path\n * @returns {array}\n */\nfunction parse(path) {\n  const data = [];\n  const p = String(path).trim();\n\n  // A path data segment (if there is one) must begin with a \"moveto\" command\n  if (p[0] !== 'M' && p[0] !== 'm') {\n    return data;\n  }\n\n  p.replace(SEGMENT_PATTERN, (_, command, args) => {\n    let type = command.toLowerCase();\n    let theArgs = parseValues(args);\n    let theCommand = command;\n    // overloaded moveTo\n    if (type === 'm' && theArgs.length > 2) {\n      data.push([theCommand].concat(theArgs.splice(0, 2)));\n      type = 'l';\n      theCommand = theCommand === 'm' ? 'l' : 'L';\n    }\n\n    // Ignore invalid commands\n    if (theArgs.length < ARG_LENGTH[type]) {\n      return '';\n    }\n\n    data.push([theCommand].concat(theArgs.splice(0, ARG_LENGTH[type])));\n\n    // The command letter can be eliminated on subsequent commands if the\n    // same command is used multiple times in a row (e.g., you can drop the\n    // second \"L\" in \"M 100 200 L 200 100 L -100 -200\" and use\n    // \"M 100 200 L 200 100 -100 -200\" instead).\n    while (\n      theArgs.length >= ARG_LENGTH[type] &&\n      theArgs.length &&\n      ARG_LENGTH[type]\n    ) {\n      data.push([theCommand].concat(theArgs.splice(0, ARG_LENGTH[type])));\n    }\n\n    return '';\n  });\n  return data;\n}\n\nmodule.exports = parse;\n","const parsePath = require('./parse-path');\n\n/**\n * Work around for https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8438884/\n * @ignore\n */\nfunction supportsSvgPathArgument(window) {\n  const canvas = window.document.createElement('canvas');\n  const g = canvas.getContext('2d');\n  const p = new window.Path2D('M0 0 L1 1');\n  g.strokeStyle = 'red';\n  g.lineWidth = 1;\n  g.stroke(p);\n  const imgData = g.getImageData(0, 0, 1, 1);\n  return imgData.data[0] === 255; // Check if pixel is red\n}\n\nfunction rotatePoint(point, angle) {\n  const nx = point.x * Math.cos(angle) - point.y * Math.sin(angle);\n  const ny = point.y * Math.cos(angle) + point.x * Math.sin(angle);\n  point.x = nx;\n  point.y = ny;\n}\n\nfunction translatePoint(point, dx, dy) {\n  point.x += dx;\n  point.y += dy;\n}\n\nfunction scalePoint(point, s) {\n  point.x *= s;\n  point.y *= s;\n}\n\nfunction polyFillPath2D(window) {\n  if (typeof window === 'undefined' || !window.CanvasRenderingContext2D) {\n    return;\n  }\n  if (window.Path2D && supportsSvgPathArgument(window)) {\n    return;\n  }\n\n  /**\n   * Crates a Path2D polyfill object\n   * @constructor\n   * @ignore\n   * @param {String} path\n   */\n  class Path2D {\n    constructor(path) {\n      this.segments = [];\n      if (path && path instanceof Path2D) {\n        this.segments.push(...path.segments);\n      } else if (path) {\n        this.segments = parsePath(path);\n      }\n    }\n\n    addPath(path) {\n      if (path && path instanceof Path2D) {\n        this.segments.push(...path.segments);\n      }\n    }\n\n    moveTo(x, y) {\n      this.segments.push(['M', x, y]);\n    }\n\n    lineTo(x, y) {\n      this.segments.push(['L', x, y]);\n    }\n\n    arc(x, y, r, start, end, ccw) {\n      this.segments.push(['AC', x, y, r, start, end, !!ccw]);\n    }\n\n    arcTo(x1, y1, x2, y2, r) {\n      this.segments.push(['AT', x1, y1, x2, y2, r]);\n    }\n\n    ellipse(x, y, rx, ry, angle, start, end, ccw) {\n      this.segments.push(['E', x, y, rx, ry, angle, start, end, !!ccw]);\n    }\n\n    closePath() {\n      this.segments.push(['Z']);\n    }\n\n    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {\n      this.segments.push(['C', cp1x, cp1y, cp2x, cp2y, x, y]);\n    }\n\n    quadraticCurveTo(cpx, cpy, x, y) {\n      this.segments.push(['Q', cpx, cpy, x, y]);\n    }\n\n    rect(x, y, width, height) {\n      this.segments.push(['R', x, y, width, height]);\n    }\n  }\n\n  function buildPath(canvas, segments) {\n    let endAngle;\n    let startAngle;\n    let largeArcFlag;\n    let sweepFlag;\n    let endPoint;\n    let midPoint;\n    let angle;\n    let lambda;\n    let t1;\n    let t2;\n    let x;\n    let x1;\n    let y;\n    let y1;\n    let r;\n    let rx;\n    let ry;\n    let w;\n    let h;\n    let pathType;\n    let centerPoint;\n    let cpx;\n    let cpy;\n    let qcpx;\n    let qcpy;\n    let ccw;\n    let startPoint = { x: 0, y: 0 };\n    const currentPoint = { x: 0, y: 0 };\n\n    canvas.beginPath();\n    for (let i = 0; i < segments.length; ++i) {\n      const s = segments[i];\n      pathType = s[0];\n\n      // Reset control point if command is not cubic\n      if (\n        pathType !== 'S' &&\n        pathType !== 's' &&\n        pathType !== 'C' &&\n        pathType !== 'c'\n      ) {\n        cpx = null;\n        cpy = null;\n      }\n\n      if (\n        pathType !== 'T' &&\n        pathType !== 't' &&\n        pathType !== 'Q' &&\n        pathType !== 'q'\n      ) {\n        qcpx = null;\n        qcpy = null;\n      }\n\n      switch (pathType) {\n        case 'm':\n        case 'M':\n          if (pathType === 'm') {\n            x += s[1];\n            y += s[2];\n          } else {\n            x = s[1];\n            y = s[2];\n          }\n\n          if (pathType === 'M' || !startPoint) {\n            startPoint = { x, y };\n          }\n\n          canvas.moveTo(x, y);\n          break;\n        case 'l':\n          x += s[1];\n          y += s[2];\n          canvas.lineTo(x, y);\n          break;\n        case 'L':\n          x = s[1];\n          y = s[2];\n          canvas.lineTo(x, y);\n          break;\n        case 'H':\n          x = s[1];\n          canvas.lineTo(x, y);\n          break;\n        case 'h':\n          x += s[1];\n          canvas.lineTo(x, y);\n          break;\n        case 'V':\n          y = s[1];\n          canvas.lineTo(x, y);\n          break;\n        case 'v':\n          y += s[1];\n          canvas.lineTo(x, y);\n          break;\n        case 'a':\n        case 'A':\n          if (pathType === 'a') {\n            x += s[6];\n            y += s[7];\n          } else {\n            x = s[6];\n            y = s[7];\n          }\n\n          rx = s[1]; // rx\n          ry = s[2]; // ry\n          angle = (s[3] * Math.PI) / 180;\n          largeArcFlag = !!s[4];\n          sweepFlag = !!s[5];\n          endPoint = { x, y };\n\n          // https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n\n          midPoint = {\n            x: (currentPoint.x - endPoint.x) / 2,\n            y: (currentPoint.y - endPoint.y) / 2,\n          };\n          rotatePoint(midPoint, -angle);\n\n          // radius correction\n          lambda =\n            (midPoint.x * midPoint.x) / (rx * rx) +\n            (midPoint.y * midPoint.y) / (ry * ry);\n          if (lambda > 1) {\n            lambda = Math.sqrt(lambda);\n            rx *= lambda;\n            ry *= lambda;\n          }\n\n          centerPoint = {\n            x: (rx * midPoint.y) / ry,\n            y: -(ry * midPoint.x) / rx,\n          };\n          t1 = rx * rx * ry * ry;\n          t2 =\n            rx * rx * midPoint.y * midPoint.y +\n            ry * ry * midPoint.x * midPoint.x;\n          if (sweepFlag !== largeArcFlag) {\n            scalePoint(centerPoint, Math.sqrt((t1 - t2) / t2) || 0);\n          } else {\n            scalePoint(centerPoint, -Math.sqrt((t1 - t2) / t2) || 0);\n          }\n\n          startAngle = Math.atan2(\n            (midPoint.y - centerPoint.y) / ry,\n            (midPoint.x - centerPoint.x) / rx\n          );\n          endAngle = Math.atan2(\n            -(midPoint.y + centerPoint.y) / ry,\n            -(midPoint.x + centerPoint.x) / rx\n          );\n\n          rotatePoint(centerPoint, angle);\n          translatePoint(\n            centerPoint,\n            (endPoint.x + currentPoint.x) / 2,\n            (endPoint.y + currentPoint.y) / 2\n          );\n\n          canvas.save();\n          canvas.translate(centerPoint.x, centerPoint.y);\n          canvas.rotate(angle);\n          canvas.scale(rx, ry);\n          canvas.arc(0, 0, 1, startAngle, endAngle, !sweepFlag);\n          canvas.restore();\n          break;\n        case 'C':\n          cpx = s[3]; // Last control point\n          cpy = s[4];\n          x = s[5];\n          y = s[6];\n          canvas.bezierCurveTo(s[1], s[2], cpx, cpy, x, y);\n          break;\n        case 'c':\n          canvas.bezierCurveTo(\n            s[1] + x,\n            s[2] + y,\n            s[3] + x,\n            s[4] + y,\n            s[5] + x,\n            s[6] + y\n          );\n          cpx = s[3] + x; // Last control point\n          cpy = s[4] + y;\n          x += s[5];\n          y += s[6];\n          break;\n        case 'S':\n          if (cpx === null || cpx === null) {\n            cpx = x;\n            cpy = y;\n          }\n\n          canvas.bezierCurveTo(\n            2 * x - cpx,\n            2 * y - cpy,\n            s[1],\n            s[2],\n            s[3],\n            s[4]\n          );\n          cpx = s[1]; // last control point\n          cpy = s[2];\n          x = s[3];\n          y = s[4];\n          break;\n        case 's':\n          if (cpx === null || cpx === null) {\n            cpx = x;\n            cpy = y;\n          }\n\n          canvas.bezierCurveTo(\n            2 * x - cpx,\n            2 * y - cpy,\n            s[1] + x,\n            s[2] + y,\n            s[3] + x,\n            s[4] + y\n          );\n          cpx = s[1] + x; // last control point\n          cpy = s[2] + y;\n          x += s[3];\n          y += s[4];\n          break;\n        case 'Q':\n          qcpx = s[1]; // last control point\n          qcpy = s[2];\n          x = s[3];\n          y = s[4];\n          canvas.quadraticCurveTo(qcpx, qcpy, x, y);\n          break;\n        case 'q':\n          qcpx = s[1] + x; // last control point\n          qcpy = s[2] + y;\n          x += s[3];\n          y += s[4];\n          canvas.quadraticCurveTo(qcpx, qcpy, x, y);\n          break;\n        case 'T':\n          if (qcpx === null || qcpx === null) {\n            qcpx = x;\n            qcpy = y;\n          }\n          qcpx = 2 * x - qcpx; // last control point\n          qcpy = 2 * y - qcpy;\n          x = s[1];\n          y = s[2];\n          canvas.quadraticCurveTo(qcpx, qcpy, x, y);\n          break;\n        case 't':\n          if (qcpx === null || qcpx === null) {\n            qcpx = x;\n            qcpy = y;\n          }\n          qcpx = 2 * x - qcpx; // last control point\n          qcpy = 2 * y - qcpy;\n          x += s[1];\n          y += s[2];\n          canvas.quadraticCurveTo(qcpx, qcpy, x, y);\n          break;\n        case 'z':\n        case 'Z':\n          x = startPoint.x;\n          y = startPoint.y;\n          startPoint = undefined;\n          canvas.closePath();\n          break;\n        case 'AC': // arc\n          x = s[1];\n          y = s[2];\n          r = s[3];\n          startAngle = s[4];\n          endAngle = s[5];\n          ccw = s[6];\n          canvas.arc(x, y, r, startAngle, endAngle, ccw);\n          break;\n        case 'AT': // arcTo\n          x1 = s[1];\n          y1 = s[2];\n          x = s[3];\n          y = s[4];\n          r = s[5];\n          canvas.arcTo(x1, y1, x, y, r);\n          break;\n        case 'E': // ellipse\n          x = s[1];\n          y = s[2];\n          rx = s[3];\n          ry = s[4];\n          angle = s[5];\n          startAngle = s[6];\n          endAngle = s[7];\n          ccw = s[8];\n          canvas.save();\n          canvas.translate(x, y);\n          canvas.rotate(angle);\n          canvas.scale(rx, ry);\n          canvas.arc(0, 0, 1, startAngle, endAngle, ccw);\n          canvas.restore();\n          break;\n        case 'R': // rect\n          x = s[1];\n          y = s[2];\n          w = s[3];\n          h = s[4];\n          startPoint = { x, y };\n          canvas.rect(x, y, w, h);\n          break;\n        default:\n        // throw new Error(`${pathType} is not implemented`); ?\n      }\n\n      currentPoint.x = x;\n      currentPoint.y = y;\n    }\n  }\n\n  const cFill = window.CanvasRenderingContext2D.prototype.fill;\n  const cStroke = window.CanvasRenderingContext2D.prototype.stroke;\n\n  window.CanvasRenderingContext2D.prototype.fill = function fill(...args) {\n    let fillRule = 'nonzero';\n    if (\n      args.length === 0 ||\n      (args.length === 1 && typeof args[0] === 'string')\n    ) {\n      cFill.apply(this, args);\n      return;\n    }\n    if (arguments.length === 2) {\n      fillRule = args[1];\n    }\n    const path = args[0];\n    buildPath(this, path.segments);\n    cFill.call(this, fillRule);\n  };\n\n  window.CanvasRenderingContext2D.prototype.stroke = function stroke(path) {\n    if (!path) {\n      cStroke.call(this);\n      return;\n    }\n    buildPath(this, path.segments);\n    cStroke.call(this);\n  };\n\n  const cIsPointInPath =\n    window.CanvasRenderingContext2D.prototype.isPointInPath;\n\n  window.CanvasRenderingContext2D.prototype.isPointInPath = function isPointInPath(\n    ...args\n  ) {\n    // let fillRule = 'nonzero';\n    if (args[0].constructor.name === 'Path2D') {\n      // first argument is a Path2D object\n      const x = args[1];\n      const y = args[2];\n      const fillRule = args[3] || 'nonzero';\n      const path = args[0];\n      buildPath(this, path.segments);\n      return cIsPointInPath.apply(this, [x, y, fillRule]);\n    } else {\n      return cIsPointInPath.apply(this, args);\n    }\n  };\n\n  window.Path2D = Path2D;\n}\n\nmodule.exports = polyFillPath2D;\n","const parsePath = require('./parse-path');\nconst path2dPolyfill = require('./path2d-polyfill');\n\nif (typeof window !== 'undefined') {\n  path2dPolyfill(window);\n}\n\nmodule.exports = {\n  path2dPolyfill,\n  parsePath,\n};\n"],"names":["ARG_LENGTH","a","c","h","l","m","q","s","t","v","z","SEGMENT_PATTERN","NUMBER","path","data","p","String","trim","replace","_","command","args","type","toLowerCase","theArgs","numbers","match","map","Number","parseValues","theCommand","length","push","concat","splice","rotatePoint","point","angle","nx","x","Math","cos","y","sin","ny","scalePoint","window","CanvasRenderingContext2D","Path2D","g","document","createElement","getContext","strokeStyle","lineWidth","stroke","getImageData","supportsSvgPathArgument","segments","parsePath","r","start","end","ccw","x1","y1","x2","y2","rx","ry","cp1x","cp1y","cp2x","cp2y","cpx","cpy","width","height","cFill","prototype","fill","cStroke","fillRule","apply","this","arguments","buildPath","call","cIsPointInPath","isPointInPath","constructor","name","canvas","endAngle","startAngle","largeArcFlag","sweepFlag","endPoint","midPoint","lambda","t1","t2","w","pathType","centerPoint","qcpx","qcpy","dx","dy","startPoint","currentPoint","beginPath","i","moveTo","lineTo","PI","sqrt","atan2","save","translate","rotate","scale","arc","restore","bezierCurveTo","quadraticCurveTo","undefined","closePath","arcTo","rect","path2dPolyfill"],"mappings":"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"}